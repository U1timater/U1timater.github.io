---
layout:     post
title:      技术支持岗笔试解析
subtitle:   某知名安全公司技术支持中心笔试题(文内有彩蛋)
date:       2019-11-09
author:     Ultimater
header-img: img/post-bg-20191109.jpg
catalog: true
tags:
    - 网络安全
---
>前几天参加了一家安全界知名公司的招聘，觉得笔试题很有意思，虽然不是很难，但对于刚入门的同学来说可以再次加深基础知识。因此放上笔试题以及较详细的解析，解析有不完善的地方的话欢迎评论区一起讨论！

# 【网络基础】

### 一、简述OSI模型的层次结构和各层的功能，并且说明HTTP、DNS、ARP、ICMP、TCP分别属于其中哪一层？

**1. OSI七层模型及其功能：**

- **物理层：** 物理层是OSI参考模型的最低层。其主要功能是利用传输介质为数据链路层提供物理连接，实现*比特流*的透明传输。

- **数据链路层：** 数据链路层负责建立和管理节点间的链路。其主要功能是通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输*数据帧*的数据链路。该层又通常分为介质访问控制（MAC）和逻辑链路控制（LCC）两个子层：MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；LCC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。

- **网络层：** 网络层是OSI模型的第三层，也是通信子网的最高一层，它在下两层（即物理层和数据链路层）的基础上向资源子网提供服务。其主要任务是通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。
    
    - 该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为*数据包*，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。
    
    - 一般地，数据链路层是解决同一个网络内节点之间的通信，而网络层主要解决不同子网间的通信。

- **传输层：** OSI下3层的主要任务是数据通信，上3层的主要任务是数据处理。而传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。该层的主要任务是向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送*报文*。因此，传输层的主要功能是：
    
    - 传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无连接”的两种服务；
    
    - 处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。
    
    - 监控服务质量

- **会话层：** 会话层是用户应用程序和网络之间的接口，主要任务是向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话，因此会话层主要就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。用户可以按照半双工、单工和全双工的方式建立会话。会话层的具体功能如下：
    
    - 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。
    
    - 会话流量控制：提供会话流量控制和交叉会话功能。
    
    - 寻址：使用远程地址建立会话连接。
    
    - 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。

- **表示层：** 表示层对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能如下：
    
    - 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。
    
    - 数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。
    
    - 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。
    
    - 数据的加密和解密：可以提高网络的安全性。

- **应用层：** 应用层是计算机用户以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。

**2. OSI各层模型常见协议或服务：**

- **物理层：** `IEEE 802.2`、`Ethernet v.2`等

- **数据链路层：** `PPTP-点对点隧道协议`、`L2TP-第二层隧道协议`、`ARP-地址解析协议`、`RARP-逆向地址解析协议`等

- **网络层：** `IP-网际协议`、`ICMP-网际控制报文协议`、`IGMP-网际组管理协议`等

- **传输层：** `TCP-传输控制协议`、`UDP-用户数据报协议`等

- **会话层：** `SSL-安全套接字层协议`、`TLS-运输层安全协议`、`RPC-远程过程调用协议`等

- **表示层：** `XDP-外部数据表示协议`、`LPP-轻量级表示协议`等

- **应用层：** `HTTP-超文本传输协议`、`FTP-文件传输协议`、`SMTP-简单邮件传输协议`、`DNS-域名解析协议`、`VT-虚拟终端仿真协议`、`DHCP-动态主机配置协议`、`SNMP-简单网络管理协议`等

### 二、简述TCP、UDP协议的区别及优缺点。

**1. TCP、UDP协议的区别：**

- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接；

- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付；

- TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；

- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；

- TCP首部开销20字节;UDP的首部开销小，只有8个字节；

- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

**2. TCP的优缺点：**

- TCP的优点：可靠，稳定。TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源；

- TCP的缺点：慢，效率低，占用系统资源高，易被攻击。TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

**3. UDP的优缺点：**

- UDP的优点：快，比TCP稍安全。UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击等；

- UDP的缺点：不可靠，不稳定。因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

### 三、简述客户端使用浏览器访问 [https://www.chaitin.cn](https://www.chaitin.cn) 获取到结果的过程中客户端与服务器端的交互过程。

>*这道题看似考察的不多，但细究起来涉及到大量前端知识点，篇幅有限就只写简单过程提供下思路，具体请移步链接或自行Google。*

**简单过程线：**
1. 键盘或触屏输入URL并回车确认
2. URL解析/DNS解析查找域名IP地址
3. 客户端和服务端进行三次握手创建TCP连接
4. 发送HTTP请求
5. HTTP报文传输过程
6. 服务器接收并处理请求
7. 服务器返回数据
8. 客户端接收数据
9. 浏览器解析并加载html
10. 断开TCP连接

**详细过程及涉及前端知识点：**

 [从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！](https://juejin.im/post/5aa5cb846fb9a028e25d2fb1)

### 四、HTTP协议中的请求和响应分别由哪几部分组成？

**1. HTTP请求：**

> HTTP请求报包含三个部分：请求行 + 请求头 + 数据体

- **请求行：** 请求行包含三个内容：method(方法) + request-URI(请求的URI) + http-version(http版本)
    - method包括有：

    方法|功能
    :--:|:--
    get|通过请求URI获得资源
    post|用于添加新的资源，用于表单提交
    put|用于修改某个内容
    delete|删除某个内容
    connect|用于代理进行传输例如SSL
    options|询问可以执行那些方法
    patch|部分文档更该
    propfind|查看属性
    proppatch|设置属性
    mkcol|创建集合
    copy|拷贝
    move|移动
    lock|加锁
    unlock|解锁
    trace|用于远程诊断服务器
    head|类似于get，用于检查对象是否存在用于得到元数据

    - 例如：`GET/sample.jspHTTP/1.1`

- **请求头：** 请求头主要包含以下内容：

    - `Accept`：指浏览器或其他客户可以接爱的MIME文件格式。Servlet可以根据它判断并返回适当的文件格式。
    - `User-Agent`：是客户浏览器名称。
    - `Host`：对应网址URL中的Web名称和端口号。
    - `Accept-Langeuage`：指出浏览器可以接受的语言种类，如en或en-us，指英语。
    - `Connection`：用来告诉服务器是否可以维持固定的HTTP连接。http是无连接的，HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接。
    - `Cookie`：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。
    - `Referer`：表明产生请求的网页URL。如比从网页/icconcept/index.jsp中点击一个链接到网页/icwork/search，在向服务器发送的GET/icwork/search中的请求中，Referer是http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪Web请求是从什么网站来的。
    - `User-Agent`：是客户浏览器名称。
    - `Content-Type`：用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得。
    - `Accept-Charset`：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1.
    - `Accept-Encoding`：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。
    - `Content-Type`:表示的是请求报文体的 MIME 类型。GET的请求消息体是空的 所以不需要指定消息体的MIME类型。
    - `Content-Length`:表示的是 post 的数据的长度。


- **数据体：** 数据体由请求时的具体情境确定。

**2. HTTP响应：**

> HTTP响应由三个部分组成，分别是状态行 + 响应头 + 响应正文。

- **状态行：** 状态行包含：HTTP-Version(http版本) + Status-Code(状态码) + Reason-Phrase(状态代码的文本描述)
    - 状态码包括有：

    状态码|描述
    :----:|:----
    1xx|指示信息–表示请求已接收，继续处理
    2xx|成功–表示请求已被成功接收、理解、接受
    3xx|重定向–要完成请求必须进行更进一步的操作
    4xx|客户端错误–请求有语法错误或请求无法实现
    5xx|服务器端错误–服务器未能实现合法的请求

    - 例如：`HTTP/1.1 200 ok`

- **响应头：** 响应头包含服务器类型，日期，长度，内容类型等。如：
    ```
    Server:Apache Tomcat/5.0.12
    Date:Mon,6Oct2003 13:13:33 GMT
    Content-Type:text/html
    Last-Moified:Mon,6 Oct 2003 13:23:42 GMT
    Content-Length:112
    ```

- **响应正文：** 响应正文就是服务器返回的HTML页面。

### 五、写出不少于8种常见HTTP返回码的含义。

**2XX(成功)：2XX的响应结果表明请求被正常响应处理了。**

> **200 OK**
>> 表示客户端发来的请求在服务端被正常处理了。

> **204 No Content**
>> 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

> **206 Partial Content**
>> 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

**3XX(重定向)：3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。**

> **301 Moved Permanently**
>> 永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。

> **302 Found**
>> 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。

> **303 See Other**
>> 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。

> **304 Not Found**
>> 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified。

> **307 Temporary Redirect**
>> 临时重定向。该状态码与302Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。

**4XX(客户端错误)：4XX的响应结果表明客户端是发生错误的原因所在。**

> **400 Bad Request**
>> 该状态码表示请求报文存在语法错误。

> **401 Unauthorized**
>> 该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。

> **403 Forbidden**
>> 该状态码表名对请求资源的访问被服务器拒绝了。

> **404 Not Found**
>> 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

**5XX(服务器错误)：5XX的响应结果表明服务器本身发生错误。**

> **500 Interna Server Error**
>> 该状态码表明服务器端在执行请求时发生了错误。也有可能时Web应用存在的bug或某些临时的故障。

> **503 Service Unavailable**
>> 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### 六、简述cookie的作用及工作原理。

**1. cookie简介**

- Cookie（复数形态：Cookies），是指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。

- Cookie是由服务端生成的，发送给客户端（通常是浏览器）的。Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie：

    - 内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。

    - 硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。

    - 所以，按存在时间，也可分为非持久Cookie和持久Cookie。

**2. 工作原理**

- 创建cookie

    当用户第一次浏览某个使用Cookie的网站时，该网站的服务器就进行如下工作：
    - 该用户生成一个唯一的识别码（Cookie id），创建一个Cookie对象；

    - 默认情况下它是一个会话级别的cookie，存储在浏览器的内存中，用户退出浏览器之后被删除。如果网站希望浏览器将该Cookie存储在磁盘上，则需要设置最大时效（maxAge），并给出一个以秒为单位的时间（将最大时效设为0则是命令浏览器删除该Cookie）；

    - 将Cookie放入到HTTP响应报头，将Cookie插入到一个 Set-Cookie HTTP请求报头中。

    - 发送该HTTP响应报文。

- 设置存储Cookie

    浏览器收到该响应报文之后，根据报文头里的Set-Cookied特殊的指示，生成相应的Cookie，保存在客户端。该Cookie里面记录着用户当前的信息。

- 发送Cookie

    当用户再次访问该网站时，浏览器首先检查所有存储的Cookies，如果某个存在该网站的Cookie（即该Cookie所声明的作用范围大于等于将要请求的资源），则把该cookie附在请求资源的HTTP请求头上发送给服务器。

- 读取Cookie

    服务器接收到用户的HTTP请求报文之后，从报文头获取到该用户的Cookie，从里面找到所需要的东西。

**3. 作用**

Cookie的根本作用就是在客户端存储用户访问网站的一些信息。典型的应用有：

- 记住密码，下次自动登录。

- 购物车功能。

- 记录用户浏览数据，进行商品（广告）推荐。


**********
# 【操作系统】

### 一、以 CentOS 7.0 为例，根据以下要求写出操作命令。

**1. 查看当前操作系统版本以及内核。**

- 查看CentOS操作系统版本

```
cat /etc/centos-release
```

- 查看内核版本

```
uname -r
```

**2. 查看 8080 端口是否被占用。**

```
netstat -anp|grep 8080
```
或者
```
lsof -i:8080
```

**3. 查看当前CPU、内存利用率。**

- 查看当前CPU利用率

```
top -bn 1 -i -c
```

- 查看当前内存利用率

```
free -m
```

**4. 查看当前是否运行mysql进程。**

```
ps -ef|grep mysqld
```

**5. 写出minion程序纳入到systemctl进行管理并设置为开机启动的配置思路。**

```
yum -y install salt-minion
systemctl enable salt-minion.service 
```

**6. 查看当前路由表。**

```
route -e
```

**7. 使用tcpdump抓取eth0接口中源IP为 1.1.1.1 和目的IP为 2.2.2.2 通信的数据包。**

```
tcpdump -i eth0 -vnn src host 1.1.1.1 and dst host 2.2.2.2
```

**8. 使用tcpdump抓取eth0接口目的端口为TCP的数据包，保存到本地/tmp目录。**

```
tcpdump -i eth0 tcp -w /tmp/xxx.cap
```

### 二、使用Wireshark查看数据包，写出以下要求的过滤规则。

**1. 只查看源IP为 1.1.1.1 和目的IP为 2.2.2.2 通信的数据包。**

```
ip.src eq 1.1.1.1 and ip.dst eq 2.2.2.2
```

**2. 只查看目的IP为 2.2.2.2、目的端口为 TCP 80 通信的数据包。**

```
ip.dst eq 2.2.2.2 and tcp.dstport == 80
```

### 三、用正则表达式匹配：192.168.33.1/24 网段。


```
^192\.168\.33\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]?\d)$
```

### 四、在/opt/目录下有一脚本 `run.py` ，现在需要每周三中午12点自动运行该脚本，写出相应操作命令。


1.安装crontabs服务

```
yum install crontabs
```

2.设置开机启动

```
systemctl enable crond 
```

3.启动crond服务

```
systemctl start crond（启动crond服务）
```

4.编辑定时任务

```
crontab -e
```

5.写入指令

```
i
00 12 * * 3 python /opt/run.py
```

6.保存并退出即可

```
Esc
:wq!
```

### 五、简述 docker 和传统虚拟化平台（如 vmware workstation ）的区别。

![虚拟机VS容器](http://ww1.sinaimg.cn/large/0063ewEmly1g8v6m87klfj30gj0aajsd.jpg)

左图的虚拟机的Guest层，还有Hypervisor层在Docker上已经被Docker Engine层所取代，在这里我们需要知道，Guest OS 是虚拟机安装的操作系统，是一个完整的系统内核，另外Hypervisor可以理解为硬件虚拟化平台，它在后Host OS以内核驱动的形式存在。

虚拟机实现资源的隔离的方式是利用独立的Guest OS，以及利用Hypervisor虚拟化CPU、内存、IO等设备来实现的，对于虚拟机实现资源和环境隔离的方案，Docker显然简单很多。

然后Docker并没有和虚拟机一样利用一个独立的Guest OS执行环境的隔离，它利用的是目前当前Linux内核本身支持的容器方式，实现了资源和环境的隔离，简单来说，Docker就是利用Namespace 实现了系统环境的隔离，利用了cgroup实现了资源的限制，利用镜像实例实现跟环境的隔离。

Docker有着比虚拟机更少的抽象层。由于Docker不需要Hypervisor实现硬件资源的虚拟化，所以运行在Docker容器上的程序，直接使用的都是实际物理机的硬件资源。因此在cpu、内存、利用率上，Docker将会在效率上具有更大的优势。此外，Docker直接利用虚拟机的系统内核，避免了虚拟机启动时所需要的系统引导时间和操作系统运行的资源消耗，利用Docker能够在几秒钟之内启动大量的容器，是虚拟机无法办到的。快速启动低资源消耗的优点，使Docker在弹性云平台自动运维系统方面具有很好的应用场景。

与虚拟机相比，Docker在以下几个方面具有很大的优势，它能够快速的交付和部署，Docker在整个开发周期都可以完美辅助你实现快速交付，Docker允许开发者本地应用，直接进入到可持续的开发流程中。例如开发者可以使用一个标准镜像构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码，Docker可以快速创建容器快速迭代应用程序，整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。

此外，容器的启动时间是秒级的，大量节约开发、测试、部署的时间。还有一个非常关键的点，就是Docker能够高效地部署和扩容，Docker容器几乎可以在任意平台上运行，包括虚拟机、物理机、公有云、私有云、个人电脑、服务器等，这种兼容性，可以让用户把一个应用程序从一个平台直接迁移到另外一个平台。Docker的兼容性和轻量性的特性可以轻松的实现负载的动态管理，你可以快速扩容或方便的下线你的应用和服务，这种速度趋近于实时！此外Docker还具有更高的资源利用率，一台主机上可以运行数千个Docker容器，容器除了运行其应用之外，基本不消耗额外的系统资源，使得应用性能高，系统开销小。

而传统的虚拟机方式则需要运行不同的应用，耗费大量的资源，此外Docker还可以有更简单的管理使用Docker只需要小小的修改就可以替代以往大量的更新工作，所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。
<!--
作者：华为云技术宅基地
链接：https://www.zhihu.com/question/48174633/answer/568562893
-->

***特性***|***虚拟机***|***容器***
:------:|:--------:|:------:
**隔离级别**|操作系统级|进程级
**隔离策略**|Hypervisor|CGroups
**系统资源**|5~15%|0~5%
**启动时间**|分钟级|秒级
**镜像存储**|GB-TB|KB-MB
**集群规模**|上百|上万
**高可用策略**|备份、容灾、迁移|弹性、负载、动态

### 六、应用层负载均衡常用的负载算法有哪些？并说明每种算法的工作原理。

**1. 负载均衡简介** 

负载均衡又分为四层负载均衡和七层负载均衡。

四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。

七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。

![四层负载均衡和七层负载均衡](http://ww1.sinaimg.cn/large/0063ewEmly1g8voc6tpihj30gm09cmxa.jpg)

**2. 七层负载均衡**

所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

> 以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。

**3. 具体实现**

目前负载均衡系统有Nginx、LVS、F5，即：

- Nginx是软件的7层负载均衡，
- LVS是内核的4层负载均衡，
- F5是硬件的4层负载均衡。

**4. Nginx的5种负载均衡算法**

1. **轮询**

    轮询是默认的方式，每个请求按时间顺序逐一分配到不同的后端服务器上。如果后台服务器上某一台宕机了，它可以自动剔除。

    缺点：可靠性低和负载分配不均衡。适用于图片服务器和静态页面服务器集群。

2. **加权轮询（wight）**

    指定轮询的几率，wight和访问比率成正比，用于后台服务器性能不均匀的情况。

3. **ip_hash**

    根据每个请求的ip的hash结果分配，因此每个固定ip能访问到同一个后端服务器，可以解决session问题。

4. **fair（第三方）**

    按照后端服务器的响应时间来分配请求，响应时间短的优先分配。

5. **url_hash（第三方）**

    按照访问url的hash结果来分配请求，每个固定的url访问同一个后端服务器。如果后端服务器是缓存时效率高。
<!--
作者：要做个好看的程序媛
链接：https://juejin.im/post/5d66930af265da03dc078146
来源：掘金
-->

******
# 【网络安全】

### 一、简述任意一种 Web 应用漏洞的原理、危害、利用方式及修复方法。





